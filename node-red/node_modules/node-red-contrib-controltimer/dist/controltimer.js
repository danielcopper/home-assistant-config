"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
module.exports = function (RED) {
    RED.nodes.registerType(helpers_1.nodeName, function (config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        RED.nodes.createNode(this, config);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const node = this;
        function getEvaluatedProperty(property, propertyType, defaultProperty) {
            return propertyType === 'num'
                ? parseInt(RED.util.evaluateNodeProperty(property, propertyType, this, null), 10) || Number(defaultProperty)
                : RED.util.evaluateNodeProperty(property, propertyType, this, null) || defaultProperty;
        }
        node.timerType = config.timerType || helpers_1.defaults.timerType;
        node.timerDurationUnit = config.timerDurationUnit || helpers_1.defaults.timerDurationUnit;
        node.timerDurationType = config.timerDurationType || helpers_1.defaults.timerDurationType;
        node.timerDuration = getEvaluatedProperty(config.timerDuration, node.timerDurationType, helpers_1.defaults.timerDuration);
        node.timerLoopTimeoutUnit = config.timerLoopTimeoutUnit || helpers_1.defaults.timerLoopTimeoutUnit;
        node.timerLoopTimeoutType = config.timerLoopTimeoutType || helpers_1.defaults.timerLoopTimeoutType;
        node.timerLoopTimeout = getEvaluatedProperty(config.timerLoopTimeout, node.timerLoopTimeoutType, helpers_1.defaults.timerLoopTimeout);
        node.loopTimeoutMessageType = config.loopTimeoutMessageType || helpers_1.defaults.loopTimeoutMessageType;
        node.loopTimeoutMessage = getEvaluatedProperty(config.loopTimeoutMessage, node.loopTimeoutMessageType, helpers_1.defaults.loopTimeoutMessage);
        node.timerMaxLoopIterationsType = config.timerMaxLoopIterationsType || helpers_1.defaults.timerMaxLoopIterationsType;
        node.timerMaxLoopIterations = getEvaluatedProperty(config.timerMaxLoopIterations, node.timerMaxLoopIterationsType, helpers_1.defaults.timerMaxLoopIterations);
        node.loopMaxIterationsMessageType = config.loopMaxIterationsMessageType || helpers_1.defaults.loopMaxIterationsMessageType;
        node.loopMaxIterationsMessage = getEvaluatedProperty(config.loopMaxIterationsMessage, node.loopMaxIterationsMessageType, helpers_1.defaults.loopMaxIterationsMessage);
        node.isConsecutiveStartActionTimerResetAllowed = (_a = config.isConsecutiveStartActionTimerResetAllowed) !== null && _a !== void 0 ? _a : helpers_1.defaults.isConsecutiveStartActionTimerResetAllowed;
        node.isRunningTimerProgressVisible = (_b = config.isRunningTimerProgressVisible) !== null && _b !== void 0 ? _b : helpers_1.defaults.isRunningTimerProgressVisible;
        node.outputReceivedMessageOnTimerTrigger = (_c = config.outputReceivedMessageOnTimerTrigger) !== null && _c !== void 0 ? _c : helpers_1.defaults.outputReceivedMessageOnTimerTrigger;
        node.outputReceivedMessageOnTimerHalt = (_d = config.outputReceivedMessageOnTimerHalt) !== null && _d !== void 0 ? _d : helpers_1.defaults.outputReceivedMessageOnTimerHalt;
        node.startTimerOnReceivalOfUnknownMessage = (_e = config.startTimerOnReceivalOfUnknownMessage) !== null && _e !== void 0 ? _e : helpers_1.defaults.startTimerOnReceivalOfUnknownMessage;
        node.resetTimerOnReceivalOfUnknownMessage = (_f = config.resetTimerOnReceivalOfUnknownMessage) !== null && _f !== void 0 ? _f : helpers_1.defaults.resetTimerOnReceivalOfUnknownMessage;
        node.isDebugModeEnabled = (_g = config.isDebugModeEnabled) !== null && _g !== void 0 ? _g : helpers_1.defaults.isDebugModeEnabled;
        node.timerTriggeredMessageType = config.timerTriggeredMessageType || helpers_1.defaults.timerTriggeredMessageType;
        node.timerTriggeredMessage = getEvaluatedProperty(config.timerTriggeredMessage, node.timerTriggeredMessageType, helpers_1.defaults.timerTriggeredMessage);
        node.timerHaltedMessageType = config.timerHaltedMessageType || helpers_1.defaults.timerHaltedMessageType;
        node.timerHaltedMessage = getEvaluatedProperty(config.timerHaltedMessage, node.timerHaltedMessageType, helpers_1.defaults.timerHaltedMessage);
        node.isStartActionEnabled = (_h = config.isStartActionEnabled) !== null && _h !== void 0 ? _h : helpers_1.defaults.isStartActionEnabled;
        node.isStopActionEnabled = (_j = config.isStopActionEnabled) !== null && _j !== void 0 ? _j : helpers_1.defaults.isStopActionEnabled;
        node.isResetActionEnabled = (_k = config.isResetActionEnabled) !== null && _k !== void 0 ? _k : helpers_1.defaults.isResetActionEnabled;
        node.isPauseActionEnabled = (_l = config.isPauseActionEnabled) !== null && _l !== void 0 ? _l : helpers_1.defaults.isPauseActionEnabled;
        node.isContinueActionEnabled = (_m = config.isContinueActionEnabled) !== null && _m !== void 0 ? _m : helpers_1.defaults.isContinueActionEnabled;
        node.actionPropertyNameType = config.actionPropertyNameType || helpers_1.defaults.actionPropertyNameType;
        node.actionPropertyName = getEvaluatedProperty(config.actionPropertyName, node.actionPropertyNameType, helpers_1.defaults.actionPropertyName);
        node.startActionNameType = config.startActionNameType || helpers_1.defaults.startActionNameType;
        node.startActionName = getEvaluatedProperty(config.startActionName, node.startActionNameType, helpers_1.defaults.startActionName);
        node.stopActionNameType = config.stopActionNameType || helpers_1.defaults.stopActionNameType;
        node.stopActionName = getEvaluatedProperty(config.stopActionName, node.stopActionNameType, helpers_1.defaults.stopActionName);
        node.resetActionNameType = config.resetActionNameType || helpers_1.defaults.resetActionNameType;
        node.resetActionName = getEvaluatedProperty(config.resetActionName, node.resetActionNameType, helpers_1.defaults.resetActionName);
        node.pauseActionNameType = config.pauseActionNameType || helpers_1.defaults.pauseActionNameType;
        node.pauseActionName = getEvaluatedProperty(config.pauseActionName, node.pauseActionNameType, helpers_1.defaults.pauseActionName);
        node.continueActionNameType = config.continueActionNameType || helpers_1.defaults.continueActionNameType;
        node.continueActionName = getEvaluatedProperty(config.continueActionName, node.continueActionNameType, helpers_1.defaults.continueActionName);
        function getDurationInMilliseconds(duration, durationUnit) {
            if (durationUnit === helpers_1.DurationUnit.MILLISECOND) {
                return duration;
            }
            if (durationUnit === helpers_1.DurationUnit.SECOND) {
                return duration * 1000;
            }
            if (durationUnit === helpers_1.DurationUnit.MINUTE) {
                return duration * 60 * 1000;
            }
            if (durationUnit === helpers_1.DurationUnit.HOUR) {
                return duration * 60 * 60 * 1000;
            }
        }
        const timerDurationInMilliseconds = getDurationInMilliseconds(node.timerDuration, node.timerDurationUnit);
        const timerLoopTimeoutInMilliseconds = getDurationInMilliseconds(node.timerLoopTimeout, node.timerLoopTimeoutUnit);
        node.status({ fill: 'grey', shape: 'ring', text: 'Idle' });
        let currentState = helpers_1.STATE.IDLE;
        let timerId;
        let pausedTimerRunningMilliseconds;
        let timerStartedAtUnixTimestamp;
        function getRunningTimerProgress() {
            if (!node.isRunningTimerProgressVisible) {
                return '';
            }
            const previousRunningDurationInMilliseconds = pausedTimerRunningMilliseconds !== null && pausedTimerRunningMilliseconds !== void 0 ? pausedTimerRunningMilliseconds : 0;
            const timerPercentageCompletion = (100 * (Date.now() - timerStartedAtUnixTimestamp + previousRunningDurationInMilliseconds)) / timerDurationInMilliseconds;
            return ` ${Number(timerPercentageCompletion).toFixed(1)}% of ${node.timerDuration} ${node.timerDurationUnit}(s)`;
        }
        function getPausedTimerProgress() {
            if (!node.isRunningTimerProgressVisible) {
                return '';
            }
            const timerPercentageCompletion = (100 * pausedTimerRunningMilliseconds) / timerDurationInMilliseconds;
            return ` ${Number(timerPercentageCompletion).toFixed(1)}% of ${node.timerDuration} ${node.timerDurationUnit}(s)`;
        }
        let clockTimerId;
        let stopIdleTimerId;
        let loopTimeoutTimerId;
        let currentLoopIteration = 0;
        function startClockTimer() {
            if (!node.isRunningTimerProgressVisible) {
                return;
            }
            clockTimerId = setInterval(() => {
                if (currentState === helpers_1.STATE.RUNNING) {
                    node.status({
                        fill: 'green',
                        shape: 'dot',
                        text: `Running${getRunningTimerProgress()}`,
                    });
                }
            }, 50);
        }
        function stopClockTimer() {
            if (!node.isRunningTimerProgressVisible) {
                return;
            }
            clearInterval(clockTimerId);
            clockTimerId = undefined;
        }
        function destroyTimer() {
            if (timerId === undefined) {
                return;
            }
            if (node.timerType === helpers_1.TIMER_TYPE.LOOP) {
                clearInterval(timerId);
            }
            if (node.timerType === helpers_1.TIMER_TYPE.DELAY) {
                clearTimeout(timerId);
            }
            timerId = undefined;
        }
        // TODO: Determine what happens when timer is paused right at the moment the timer expires
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        node.on('input', (message, send, done) => {
            const isStartActionMessage = message[node.actionPropertyName] === node.startActionName && node.isStartActionEnabled;
            const isResetActionMessage = message[node.actionPropertyName] === node.resetActionName && node.isResetActionEnabled;
            const isPauseActionMessage = message[node.actionPropertyName] === node.pauseActionName && node.isPauseActionEnabled;
            const isContinueActionMessage = message[node.actionPropertyName] === node.continueActionName && node.isContinueActionEnabled;
            const isStopActionMessage = message[node.actionPropertyName] === node.stopActionName && node.isStopActionEnabled;
            const isUnknownMessage = !(isStartActionMessage || isResetActionMessage || isPauseActionMessage || isContinueActionMessage || isStopActionMessage);
            function startStoppedIdleTimer() {
                stopStoppedIdleTimer();
                stopIdleTimerId = setTimeout(() => {
                    finishTimer();
                }, 1000 * 10);
            }
            function stopStoppedIdleTimer() {
                clearTimeout(stopIdleTimerId);
                stopIdleTimerId = undefined;
            }
            function startLoopTimeoutTimer() {
                if (node.timerType !== helpers_1.TIMER_TYPE.LOOP || (node.timerType === helpers_1.TIMER_TYPE.LOOP && node.timerLoopTimeout === 0)) {
                    return;
                }
                stopLoopTimeoutTimer();
                loopTimeoutTimerId = setTimeout(() => {
                    stopTimer(true, node.loopTimeoutMessage);
                }, timerLoopTimeoutInMilliseconds);
            }
            function stopLoopTimeoutTimer() {
                if (loopTimeoutTimerId === undefined) {
                    return;
                }
                clearTimeout(loopTimeoutTimerId);
                loopTimeoutTimerId = undefined;
            }
            function finishTimer() {
                stopLoopTimeoutTimer();
                stopClockTimer();
                destroyTimer();
                pausedTimerRunningMilliseconds = undefined;
                timerStartedAtUnixTimestamp = undefined;
                currentLoopIteration = 0;
                currentState = helpers_1.STATE.IDLE;
                node.status({ fill: 'grey', shape: 'ring', text: 'Idle' });
            }
            function handleLoopMaxIterations() {
                currentLoopIteration = currentLoopIteration + 1;
                if (currentLoopIteration === node.timerMaxLoopIterations) {
                    stopTimer(true, node.loopMaxIterationsMessage);
                }
            }
            function createAndGetTimer(durationInMillisecondsOverride) {
                startLoopTimeoutTimer();
                currentLoopIteration = 0;
                if (node.timerType === helpers_1.TIMER_TYPE.LOOP) {
                    return setInterval(() => {
                        const outputMessage = node.outputReceivedMessageOnTimerTrigger ? RED.util.cloneMessage(message) : { [node.actionPropertyName]: node.timerTriggeredMessage };
                        node.send([outputMessage, null]);
                        timerStartedAtUnixTimestamp = Date.now();
                        pausedTimerRunningMilliseconds = undefined;
                        if (durationInMillisecondsOverride && durationInMillisecondsOverride !== timerDurationInMilliseconds) {
                            resetTimer();
                        }
                        handleLoopMaxIterations();
                    }, durationInMillisecondsOverride !== null && durationInMillisecondsOverride !== void 0 ? durationInMillisecondsOverride : timerDurationInMilliseconds);
                }
                if (node.timerType === helpers_1.TIMER_TYPE.DELAY) {
                    return setTimeout(() => {
                        const outputMessage = node.outputReceivedMessageOnTimerTrigger ? RED.util.cloneMessage(message) : { [node.actionPropertyName]: node.timerTriggeredMessage };
                        node.send([outputMessage, null]);
                        finishTimer();
                    }, durationInMillisecondsOverride !== null && durationInMillisecondsOverride !== void 0 ? durationInMillisecondsOverride : timerDurationInMilliseconds);
                }
            }
            function sendError(error) {
                if (done) {
                    // Node-RED 1.0 compatible
                    done(error);
                }
                else {
                    // Node-RED 0.x compatible
                    node.error(error, message);
                }
            }
            function startTimer() {
                startLoopTimeoutTimer();
                stopStoppedIdleTimer();
                destroyTimer();
                timerId = createAndGetTimer();
                pausedTimerRunningMilliseconds = undefined;
                timerStartedAtUnixTimestamp = Date.now();
                startClockTimer();
                currentState = helpers_1.STATE.RUNNING;
                node.status({ fill: 'green', shape: 'dot', text: `Running${getRunningTimerProgress()}` });
            }
            function stopTimer(timerWasRunning, stopMessage) {
                stopLoopTimeoutTimer();
                stopClockTimer();
                destroyTimer();
                timerId = undefined;
                pausedTimerRunningMilliseconds = undefined;
                timerStartedAtUnixTimestamp = undefined;
                currentLoopIteration = 0;
                currentState = helpers_1.STATE.STOPPED;
                node.status({ fill: 'red', shape: 'dot', text: 'Stopped' });
                if (timerWasRunning && !stopMessage) {
                    const outputMessage = node.outputReceivedMessageOnTimerHalt ? RED.util.cloneMessage(message) : { [node.actionPropertyName]: node.timerHaltedMessage };
                    node.send([null, outputMessage]);
                }
                if (timerWasRunning && stopMessage) {
                    const outputMessage = {
                        [node.actionPropertyName]: stopMessage,
                    };
                    node.send([null, outputMessage]);
                }
                startStoppedIdleTimer();
            }
            function pauseTimer() {
                stopLoopTimeoutTimer();
                stopClockTimer();
                destroyTimer();
                const previousRunningDurationInMilliseconds = pausedTimerRunningMilliseconds !== null && pausedTimerRunningMilliseconds !== void 0 ? pausedTimerRunningMilliseconds : 0;
                pausedTimerRunningMilliseconds = Date.now() - timerStartedAtUnixTimestamp + previousRunningDurationInMilliseconds;
                timerStartedAtUnixTimestamp = undefined;
                currentState = helpers_1.STATE.PAUSED;
                node.status({ fill: 'yellow', shape: 'dot', text: `Paused${getPausedTimerProgress()}` });
                const outputMessage = node.outputReceivedMessageOnTimerHalt ? RED.util.cloneMessage(message) : { [node.actionPropertyName]: node.timerHaltedMessage };
                node.send([null, outputMessage]);
            }
            function resetTimer() {
                stopClockTimer();
                destroyTimer();
                timerId = createAndGetTimer();
                pausedTimerRunningMilliseconds = undefined;
                timerStartedAtUnixTimestamp = Date.now();
                startClockTimer();
                currentState = helpers_1.STATE.RUNNING;
                node.status({ fill: 'green', shape: 'dot', text: `Running${getRunningTimerProgress()}` });
            }
            function continueTimer() {
                timerId = createAndGetTimer(timerDurationInMilliseconds - pausedTimerRunningMilliseconds);
                timerStartedAtUnixTimestamp = Date.now();
                startClockTimer();
                currentState = helpers_1.STATE.RUNNING;
                node.status({ fill: 'green', shape: 'dot', text: `Running${getRunningTimerProgress()}` });
            }
            if (currentState === helpers_1.STATE.IDLE) {
                if (isStartActionMessage) {
                    startTimer();
                    done();
                    return;
                }
                if (node.startTimerOnReceivalOfUnknownMessage && isUnknownMessage) {
                    startTimer();
                    done();
                    return;
                }
            }
            if (currentState === helpers_1.STATE.RUNNING) {
                if (isStartActionMessage && node.isConsecutiveStartActionTimerResetAllowed) {
                    resetTimer();
                    done();
                    return;
                }
                if (isResetActionMessage) {
                    resetTimer();
                    done();
                    return;
                }
                if (node.resetTimerOnReceivalOfUnknownMessage && isUnknownMessage) {
                    resetTimer();
                    done();
                    return;
                }
                if (isStopActionMessage) {
                    stopTimer(true);
                    done();
                    return;
                }
                if (isPauseActionMessage) {
                    pauseTimer();
                    done();
                    return;
                }
            }
            if (currentState === helpers_1.STATE.STOPPED) {
                if (isStartActionMessage) {
                    startTimer();
                    done();
                    return;
                }
                if (node.startTimerOnReceivalOfUnknownMessage && isUnknownMessage) {
                    startTimer();
                    done();
                    return;
                }
            }
            if (currentState === helpers_1.STATE.PAUSED) {
                if (isStartActionMessage && node.isConsecutiveStartActionTimerResetAllowed) {
                    resetTimer();
                    done();
                    return;
                }
                if (isResetActionMessage) {
                    resetTimer();
                    done();
                    return;
                }
                if (node.resetTimerOnReceivalOfUnknownMessage && isUnknownMessage) {
                    resetTimer();
                    done();
                    return;
                }
                if (isStopActionMessage) {
                    stopTimer(false);
                    done();
                    return;
                }
                if (isContinueActionMessage) {
                    continueTimer();
                    done();
                    return;
                }
            }
            if (node.isDebugModeEnabled) {
                sendError(new Error(`Can't trigger "${message[node.actionPropertyName]}" action while state is "${currentState}"!`));
            }
        });
        node.on('close', (done) => {
            clearInterval(clockTimerId);
            clearInterval(loopTimeoutTimerId);
            stopClockTimer();
            destroyTimer();
            pausedTimerRunningMilliseconds = undefined;
            timerStartedAtUnixTimestamp = undefined;
            done();
        });
    });
};
